from collections import namedtuple
import pandas as pd

# we will need to 'pool' estimates, collapsing values from multiple estimates to one
# here are functions that do that for each variable
PoolingFnMap = namedtuple(typename = 'PoolingFnMap',
                          field_names = ['summary_type',
                                         'column_names',
                                         'summary_function'])

# helper function to use to generate lambdas
def get_unique_value(series, default = pd.NA):
    unique_vals = series.unique()
    if len(unique_vals) == 1:
        return unique_vals[0]
    else:
        return default

pooling_function_maps = [
    PoolingFnMap(summary_type = 'sum',
                 column_names = ['denominator_value',
                                 'case_count_0',
                                 'case_count_neg14',
                                 'case_count_neg9',
                                 'case_population',
                                 'death_count_plus11',
                                 'death_count_plus4',
                                 'deaths_population'],
                 summary_function = lambda estimates, col: estimates[col].sum(skipna = True)),
    PoolingFnMap(summary_type = 'union',
                 column_names = ['state',
                                 'city',
                                 'antibody_target',
                                 'test_manufacturer'],
                 summary_function = lambda estimates, col: estimates[col].explode().dropna().unique()),
    PoolingFnMap(summary_type = 'min',
                 column_names = ['sampling_start_date',
                                'age_min'],
                 summary_function = lambda estimates, col: estimates[col].min()),
    PoolingFnMap(summary_type = 'max',
                 column_names = ['sampling_end_date',
                                 'date_created',
                                 'last_modified_time',
                                 'publication_date',
                                 'age_max'],
                 summary_function = lambda estimates, col: estimates[col].max()),
    PoolingFnMap(summary_type = 'mean',
                 column_names = ['pin_latitude',
                                 'pin_longitude'],
                 summary_function = lambda estimates, col: estimates[col].mean()),
    PoolingFnMap(summary_type = 'logical_AND',
                 column_names = ['academic_primary_estimate',
                                 'dashboard_primary_estimate',
                                 'pop_adj',
                                 'test_adj',
                                 'superceded',
                                 'geo_exact_match'],
                 summary_function = lambda estimates, col: estimates[col].fillna(True).max()),
    PoolingFnMap(summary_type = 'unique_value_or_na',
                 column_names = ['country',
                                 'country_iso3',
                                 'gbd_region',
                                 'gbd_subregion',
                                 'lmic_hic',
                                 'subgroup_var',
                                 'subgroup_cat'],
                 summary_function = lambda estimates, col: get_unique_value(estimates[col], pd.NA)),
    PoolingFnMap(summary_type = 'unique_value_population_group',
                 column_names = ['population_group'],
                 summary_function = lambda estimates, col: get_unique_value(estimates[col], 'Multiple populations')),
    PoolingFnMap(summary_type = 'unique_value_age',
                 column_names = ['age'],
                 summary_function = lambda estimates, col: get_unique_value(estimates[col], 'Multiple groups')),
    PoolingFnMap(summary_type = 'unique_value_population_group',
                 column_names = ['sex'],
                 summary_function = lambda estimates, col: get_unique_value(estimates[col], 'All')),
    PoolingFnMap(summary_type = 'unique_value_genpop',
                 column_names = ['genpop'],
                 summary_function = lambda estimates, col: get_unique_value(estimates[col], 'Study examining special population seroprevalence')),
    PoolingFnMap(summary_type = 'unique_value_isotype_comb',
                 column_names = ['isotype_comb'],
                 summary_function = lambda estimates, col: get_unique_value(estimates[col], 'AND')),
    PoolingFnMap(summary_type = 'unique_value_specimen_test_type',
                 column_names = ['specimen_type', 'test_type'],
                 summary_function = lambda estimates, col: get_unique_value(estimates[col], 'Multiple Types')),
    PoolingFnMap(summary_type = 'unique_value_test_validation',
                 column_names = ['genpop'],
                 summary_function = lambda estimates, col: get_unique_value(estimates[col], 'Multiple tests with diff validations or values derived from each type')),
    PoolingFnMap(summary_type = 'concatenate_with_semicolons',
                 column_names = ['sample_frame_info',
                                 'test_name',
                                 'subgroup_specific_category'],
                 summary_function = lambda estimates, col: '; '.join(estimates[col].unique())),
    PoolingFnMap(summary_type = 'identity_from_max_denominator',
                 column_names = ['test_manufacturer',
                                 'sensitivity'
                                 'specificity',
                                 'ind_se',
                                 'ind_sp',
                                 'number_of_females',
                                 'number_of_males',
                                 'ind_se_n',
                                 'ind_sp_n',
                                 'se_n',
                                 'sp_n'
                                 'age_variation',
                                 'average_age',
                                 'ind_eval_lab',
                                 'ind_eval_link',
                                 'test_linked_uid',
                                 'url',
                                 'first_author',
                                 'lead_organization',
                                 'source_publisher',
                                 'summary'
                                 'jbi_1', 'jbi_2', 'jbi_3',
                                 'jbi_4', 'jbi_5', 'jbi_6',
                                 'jbi_7', 'jbi_8', 'jbi_9',
                                 'measure_of_age',
                                 'overall_risk_of_bias',
                                 'source_name',
                                 'study_name',
                                 'source_id',
                                 'study_type',
                                 'age_variation_measure',
                                 'sampling_type',
                                 'pin_region_type'],
                 summary_function = None),
    PoolingFnMap(summary_type = 'weighted_average_by_denominator',
                 column_names = ['serum_pos_prevalence',
                                 'cases_per_hundred',
                                 'deaths_per_hundred',
                                 'full_vaccinations_per_hundred',
                                 'vaccinations_per_hundred',
                                 'tests_per_hundred'],
                 summary_function = lambda estimates, col: (estimates[col] * estimates['denominator_value']).sum() / estimates['denominator_value'].sum()),
]